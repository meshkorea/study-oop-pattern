# 객체 설계원칙

Date: Mar 29, 2021
Tags: SOLID

# 설계 원칙: SOLID

객체를 설계하는데 있어 참고할 수 있는 좋은 설계원칙이 될 수 있다. (반드시 만족하지는 않음)

## 단일 책임 원칙(SRP, Single Responsibility Principle)

**클래스는 단 한개의 책임을 가져야 한다.**

- 객체지향의 기본은 책임을 객체에 할당하는 데 있다.
- 객체를 객체로 존재하게 하는 이유는 **책임**때문이기도 하다.
- 클래스를 변경하는 이유는 단 한 개여야 한다.

**왜 하나의 책임을 가지는게 좋을까?**

- 클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문 (즉 책임을 많이 가질수록 변경될 가능성 또한 높아진다.)

SRP를 지키지 못하면 다른 객체지향 설계원칙의 효과들도 반감될 수 있다.

## 개방 폐쇄 원칙 (OCP, Open-Closed Principle)

**확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

- 기능을 변경하거나 확장할 수 있으면서
- 그 기능을 사용하는 코드는 수정하지 않는다.

개방 폐쐐 원칙을 지키는 방법은 무엇일까?

- 변화 할 수 있는 부분을, 추상화, 다형성을 이용하여 확장시키는 방법 (`interface`)
    - `interface`를 구현한 클래스를 사용하는 경우, interface에는 추상 메소드로 정의만 되어있기 때문에 직접 변경되지 않고 구현부에서 변경된다( 개방폐쇄원칙 O)
    - 추상화, 다형성은 꼭 interface여야 할까?(NO)
- 상속을 이용하여 상위 클래스의 기능을 그대로 사용하면서 하위 클래스에서 일부 기능을 오버라이딩 하는 방법

결론: **변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다.**

## 리스코프 치환 원칙(LSP, Liskov Substitution Principle)

리스코프 치환원칙은 개방 폐쇄 원칙을 받쳐주는 다형성에 관한 원칙을 제공한다.

**상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.**

리스코프 치환원칙이 지켜지지 않으면 다형성에 기반한 개방 폐쇄 원칙 역시 지켜지지 않기 때문에, 리스코프 치환원칙을 지키는것은 매우 중요하다.

```java
public SuperClass {
	public someMethod() {}
}

public SubClass extends SuperClass {
//	@Override
//	public someMethod() {}
}

// main 영역

public void call(Superclass sc) {
	// 다형성에 의해 sc의 인스턴스는 SubClass로 주입될 수도 있는데 
	// 같은 타입의 객체라면, 어떤 하위 타입의 인스턴스가 오던지간에,
  // 정상적으로 동작하는 것을 항상 보장 할 수 있는가?
	sc.someMethod(); 
}
```

리스코프 치환 원칙은 기능의 명세에 대한 내용이다.

기능 명세와 관련해서 흔히 발생하는 위반 사례로는 다음과 같은 것들이 있다.

- 명세에서 벗어난 값을 리턴한다.
    - 리턴 값은 0 혹은 그 이상을 리턴하도록 정의되어 있지만, 하위 타입에서 음수 값을 리턴
- 명세에서 벗어난 익셉션을 발생한다
    - IOException만 발생시킨다고 명세했는데, 하위 타입에서 IllegalArgumentException을 발생
- 명세에서 벗어난 기능을 수행한다

위와 같이 하위 타입이 상위 타입에서 정의한 명세를 벗어난다면 리스코프 치환원칙이 만족하지 못하는 것이다.

`instanceof` 와 같은 키워드가 있거나 어떤 타입의 하위타입을 확인하기 위한 코드가 있다면 LSP를 위반햇을 확률이 높다.

## 인터페이스 분리 원칙(ISP, Interface Segregation Principle)

**인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야한다.**

클라이언트는 자신이 사용하는 메소드에만 의존해야 한다.

클라이언트 입장에서 분리해야 한다.

## 의존 역전 원칙(DIP, Dependency Inversion Principle)

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상타입에 의존해야한다.

이는 컴파일 수준에서의 의존을 의미한다.