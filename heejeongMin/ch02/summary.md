1. 절차지향
    * 데이터를 중심으로 구현하게 된다. 
    * 요구사항이 변경되어 기본 기능에 대해 상태를 추가하는 경우 이를 사용하는 모든 프로시져들에 변경을 해주어야한다. 
    * 프로그램의 규모가 커져서 같은 데이터를 서로 달른 의미로 사용하는 경우 발생

2. 객체지향
    * 프로시져를 객체라는 단위로 묶고 객체들이 모여 프로그램을 구성한다. 
    
3. 객체 
    * 객체지향의 가장 기본은 객체이고 객체를 정의할때 사용되는 것은 객체가 제공해야할 기능이다. 
      객체가 내부적으로 어떤 기능을 가지고 있는지로는 정의되지 않는다. 
        - 예제. 소리크기 제어 객체가 제공하는 기능이 다음과 같은 경우, 이 객체가 소리크기를 내부적으로 어떤 데이터 타입 값으로 
        저장하는지는 중요하지 않고, 어떻게 소리크기를 증가/감소시키는지 중요하지 않다. 단지 이 3가지 기능을 제공하는게 중요하다.
            1. 소리 크기 증가
            2. 소리 크기 감소
            3. 음 소거
            
4. 인터페이스와 클래스
    * 객체가 제공하는 모든 기능의 집합을 객체의 인터페이스라고 부른다.
    * 인터페이스는 객체를 사용하기 위한 일종의 명세나 규칙이다. 
    * 인터페이스는 객체가 제공하는 기능에 대한 명세일 뿐, 실제 객체가 어떤 기능을 어떻게 구현하는지에 대한 내용은 포함하지 않는다. 
      실제 객체의 구현을 정의하는 것은 클래스이다. 
      
5. 메세지
    * 객체지향은 기능을 제공하는 여러 객체들이 모여서 완성된 어플리케이션을 구성한다. 
    * 객체끼리 오퍼레이션 실행을 요청하는 것을 메시지를 보낸다고 표현하고 자바의 경우 메서드를 호출하는 것이 메시지를 보내는 것이다.
    
6. 객체의 책임과 크기
    * 객체는 제공하는 기능으로 정의된다고 하였고 다시말하면 객체마다 자신의 책임을 가지고 있다는 의미이다. 
    * 객체가 갖는 책임을 결정하는 것이 객체 지향 설계의 출발점이고, 가장 어려우면서도 중요하다.  
    * 프로그램 설계 시 기능을 나열해 보고, 이 기능들을 어떻게 분배하느냐에 따라 객체의 구성이 달라진다. 
      다양한 조합이 존재할 수 있기 때문에 알맞은 구성을 찾아내는 것이 쉽지않고, 답이 1개이지도 않다. 
    * 한 객체가 갖는 책임은 작을 수록 좋다. 한 객체에 기능이 많아지면 데이터를 공유해서 사용하게되고 절차지향적인 구조를 갖게된다.
      절차지향의 가장 큰 단점은 기능변경의 어려움이 생기게 된다.
    * 그래서 단일 책임의 원칙! (SRP : Single Responsibility Principle) 이 나오게 된다. 
      한 객체는 단 한개의 책임만을 가져야한다. 단일책임의 원책을 따르다 보면 자연스럽게 기능의 세부 내용이 변경이 되면, 
      변경해야할 부분이 한 곳으로 집중되게 된다. 
      
7. 의존
    * 객체지향적으로 프로그램을 구현하다 보면, 다른 객체가 제공하는 기능을 이용해서 자신의 기능을 완성하는 객체가 출현하게 된다. 
        - 흐름제어 -> 파일읽기
                  -> byte암호 
                  -> 파일쓰기
          위 경우, 흐름제어 객체는 나머지 3개의 객체를 이용하여 암호화 프로그램의 실행기능을 완성한다. 
    * 한 객체가 다른 객체를 생성하거나, 다른 객체의 메서드를 호출할 때 이를 그 객체에 의존(dependency)한다고 표현한다.
    * 의존이 생기면, 한 객체에 변경이 생기면 의존하는 긱체에 변경이 생길 가능성이 있다. 
    * 의존은 전파되는 특징을 가지기 때문에 순환해서 발생할 경우, 다른 방법이 있는지 고민해야 한다. 
      -> 의존역전원칙(Dependency inversion principle: DIP)
      
8. 캡슐화
    * 객체지향의 장점은 한곳의 구현 변경이 다른 곳에 변경을 가하지 않도록 해준다는데 있다. 즉 수정을 좀 더 원할하게 할 수 
      있도록 하는 것이 객체 지향적으로 프로그래밍을 하는 이유이다.
    * 캡슐화(encapsulation)가 한곳의 변화가 다른 곳에 미치는 영향을 최소화 해준다. 캡슐화의 정의는 객체가 내부적으로 기능을
      어떻게 구현하는지를 감추는 것이다. 이를 통해 내부 구현이 변경되더라도 그 기능을 사용하는 코드가 영향을 받지 않도록 하는 것이다. 
        - 회원의 만료 기준을 일일히 여러곳에서 조건체크하면서 거르는 것이 아니라, 해당 로직을 한 객체의 메서드 안에 정의하고,
          외부에서는 해당 메서드를 호출해서 사용한다. 추후 로직에 변경이 생겨도 해당 메서드만 수정하면 되고 호출하는 쪽은 변경하지
          않아도 되는 것이다!
    * 캡술화를 위한 두 개의 규칙
        - Tell, Don't Ask : 데이터를 물어보지 않고 기능을 실행해달라고 하는 규칙.
            1. 회원만료 로직을 직접 데이터를 읽어서 여러곳에 구현하는 것이 아니라, 해당 기능을 실행해 달라고 명령을 내리는
               방색으로 코딩한다. 
        - 데미테르의 법칙 (Law of Demeter) : Tell, Don't Ask 규칙을 따를 수 있도록 만들어 주는 또다른 규칙이다.  
            1. 메서드에서 생성한 객체의 메서드만 호출
            2. 파라미터로 받은 객체의 메서드만 호출
            3. 필드로 참조하는 객체의 메서드만 호출
            -  위반의 예제
                ``` JAVA
                 public void proccess(Member member){
                     if(member.getDate().getTime()) { ... } 
                    }
                ```
                이유 : 파라미터로 받은 Member 객체의 메서드만 호출해야하는데 getDate를 호출한 뒤, getDate가 리턴한
                      Date객체의 getTime() 메서드를 호출했기 때문이다. 데미테르의 법칙 중 "메서드에서 생성한 객체의
                      메서드만 호출" 을 지키려면 getDate(), getTime() 을 캡슐화한 getSomeMehtod()가 있어야한다.
                데미테르의 법칙을 어기는 전향적인 증상은 
                * 연속된 get 메서드 호출
                * 임시 변수의 get 호출이 많  음
                
                
9. 객체 지향 설계 과정 
- 다음 작업을 반복하는 것이 객체 지향 설계라고 할 수 있다.
    1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능 알맞은 객체에 할당한다.
       * 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수 있다. 
       * 기능은 최대한 캡슐화해서 구현한다. 
    2. 객체 간에 어떻게 메세지를 주고 받을 지 결정한다.
    3. 과정 1과 과정 2를 개발하는동안 지속적으로 반복한다. 
     
   
   
   
TOD : UML Distilled 3/E 한국어판 (마틴 파울러)
      
    