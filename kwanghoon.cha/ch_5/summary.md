# SOLID

## 1. 단일 책임 법칙 (SRP)
```
클래스는 단 한개의 책임을 가져야 한다.
```
- 클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생

- 가장 중요한 원칙중 하나

### 단일 책임 원칙의 위반이 가져오는 문제점 
- 책임의 개수가 많아질수록 한 책임의 기능 변화가 다른 책임에 주는 영향은 비례해서 증가하여, 결국 코드를 절차 지향적으로 만들어 변경을 어렵게 할 수 있다.
- 재사용을 어렵게 한다.

`책임`이란 `변화`에 대한 것
- 단일 책임 원칙을 잘 지켰는지 확인하고싶을 땐, `사용자`가 누구인지 확인해보는것이 중요하다. </br>
    사용자들이 서로 다른 메서드를사용 한다면 메서드는 각각 다른 책임에 속할 가능성이 높다.

## 2. 개방 폐쇄 법칙 (OCP)
```
확장에는 열려 있어야하고, 변경에는 닫혀 있어야 한다.
```
-> 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.

**OCP를 구현하는 방법**
* 확장(변화)되는 부분을 추상화
* 상속을 이용

### 개방 폐쇄 원칙이 깨질때 발생 되는 증상
보통 `추상화`와 `다형성`이 제대로 지켜지지 않은 코드가 개방 폐쇄 원칙을 어기게 된다.

**특징**
* 다운 캐스팅을 한다.
* 비슷한 if-else 블록이 존재한다.


개방 폐쇄 원칙은 `유연함`에 대한 것
- 개방 폐쇄 원칙은 변화가 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다.
- 변경 요구가 생길때마다, 변화와 관련된 구현을 추상화 하는 노력, 습관이 필요


## 3. 리스코프 치환 법칙 (LSP)
```
상위 타입의 객체를 하위타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다.
```

### 리스코프 치환 원칙을 지키지 않았을 때 문제
* 개념적으로 상속관계에 있는 것처럼 보일지라도 실제 구현에서는 다를수 있는 점
* 상위타입에서 지정한 리턴 값의 범위에 해당되지 않는 값 리턴

리스코프 치환 원칙은 `계약`과 `확장`에 관한 것

**기능 실행의 계약과 관련한 위반 사례**
* 명시된 명세에서 벗어난 값을 리턴한다.
* 명시된 명세에서 벗어난 익셉션을 발생한다.
* 명시된 명세에서 벗어난 기능을 수행한다.

리스코프 치환 원칙을 어기면 개방-폐쇄 원칙을 어겼을 가능성이 높다. 

## 4. 인터페이스 분리 법칙 (ISP)
```
클라이언트는 자신이 사용하는 메서드에만 의존 해야 한다.
(=>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해아 한다.)
```

### 인터페이스 분리 원칙
인터페이스를 각 클라이언트가 필요로 하는 인터페이스 들로 분리 함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 해야 한다.

용도에 맞게 분리하는것이 단일 책임 원칙과도 연결된다.


인터페이스 분리 원칙은 `클라이언트`에 대한 것
* 인터페이스를 분리하는 기준은 클라이언트
* 클라이언트가 사용하는 긴으을 중심으로 인터페이스를 분리함으로써, 인터페이스의 변경의 여파가 다른 클라이언트에 미치는 영향을 최소화 할 수 있게 된다.

## 5. 의존 역전 법칙 (DIP)
```
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 저수준 모듈이 고수준 모듈에서 정의한 추상타입에 의존해야한다.
```

저수준 모듈은 변경되더라도, 고수준 모듈은 변경되지 않게 하는 것

### 의존 역전 원칙을 통한 변경의 유연함 확보

* `추상화`를 통해 문제를 해결
* 고수준 모듈이 저수준 모듈을 직접 의존하는것이 아니라 추상타입을 만들어 고수준, 저수준 모듈 모두 추상타입에 의존하게 한다.

이것은 소스코드 상에서의 의존 방향 분리이지, 실제 런타임에서는 의존을 역전시키는것은 아님
